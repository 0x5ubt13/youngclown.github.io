---
layout: post
title: "CQRS"
comments: true
---

CQRS는 네이밍에서 알 수 있듯이 명령과 쿼리의 역할을 구분 한다는 겁니다.
커맨드 ( Create - Insert, Update, Delete : 데이터를 변경) 와 쿼리 ( Select - Read : 데이터를 조회)의 책임을 분리한다는 것인데요.

Martin Fowler 형님께서 이미 2011년도에 이야기 하셨던, 등장한지는 조금 오래된 패턴입니다. [참고주소](https://martinfowler.com/bliki/CQRS.html)
(참고로 버란트 마이어(Bertrand Meyer) 의 CQS가 CQRS의 출발 이었고, CQRS를 처음 소개한 이는 Greg Young 이라고 합니다.)

사업이 망하지 않는 한,
전통적인 CRUD 아키텍처 기반에서 Application을 개발 및 운영하는 개발자들에게는 자연스레 Domain Model의 복잡도가 증가될 겁니다.
그리고 그로 인하여 히스토리를 간직해야할 유지보수 Cost는 지속적으로 증가하게 되며 Domain Model은 점점 설계 시 의도한 방향에서 벗어나게 될 겁니다.

이런 일련의 변경사항과 흐름을 곰곰히 관찰해 보며,
단순 검색 및 조회만 하면되는 데이터를,
비즈니스 로직이 거대해지면서 CUD에 의해 변경되는 도메인모델들이 의미없이 늘어나며,
그 모델들을 조인해서 가져와야하는 단순 검색결과들 또한 비대해지게 됩니다.

그리고 그 해답으로 나온 것이 CQRS 입니다.
바로 명령을 처리하는 책임과 조회를 처리하는 책임을 분리 구현 하자는 취지가 바로 이것입니다.

전통적으로 사용하는 CRUD 모델의 경우 데이터를 갱신하기 위해서는 데이터 저장소에서 해당 데이터를 가져오는 작업이 필요합니다.
동시성 문제가 나타날수도 있고, 확장성을 낮추는 문제점을 지닌 지점이 되기 쉽습니다.

CQRS 의 경우 어떻게 보면 일련의 이벤트를 통해 데이터를 조작하는 접근방식이 될 수 있겠습니다.
데이터에 영향을 주는 모든 동작을 이벤트라는 저수준의 데이터로 관리하는 것으로 여러 문제를 해결할 수 있습니다.

<iframe width="560" height="315" src="https://www.youtube.com/embed/12EGxMB8SR8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Testing Your Message-Driven Application by Jakub Pilimon @ Spring I/O 2018

<iframe width="560" height="315" src="https://www.youtube.com/embed/gruKbf8Co6s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

서울에서 한 스프링원에 참석해서 집적 들어봤습니다. 그때는 우리 솔류션에 적용하기 힘들 것같다고 생각했는데,
어느순간 적용가능한 시점이 다가온거 같네요.
